; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	C:\Users\DAVE\Documents\Programming\Visual_Studio_6\EXE\Console\SoundOff\SoundOff\SOff_GetUnicodeStringPointer.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__LoadStringW@16:PROC
EXTRN	@__security_check_cookie@4:PROC
PUBLIC	_SOff_GetUnicodeStringPointer@12
; Function compile flags: /Ogtp
; File c:\users\dave\documents\programming\visual_studio_6\exe\console\soundoff\soundoff\soff_getunicodestringpointer.c
;	COMDAT _SOff_GetUnicodeStringPointer@12
_TEXT	SEGMENT
_lpTheString$ = -4					; size = 4
_plpuintLength$dead$ = 8				; size = 4
_SOff_GetUnicodeStringPointer@12 PROC			; COMDAT
; _phSourceModule$dead$ = ecx
; _puintStringID$ = edx

; 14   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 15   : 	LPTSTR lpTheString = NULL ;
; 16   : 
; 17   : 	if ( plpuintLength )
; 18   : 	{	// The documented return value of LoadString excludes the trailing null. However, when nBufferMax = RCDATA_INPLACE_POINTER, it is included.
; 19   : 		if ( *plpuintLength = ( LoadString ( phSourceModule ,					// _in_     HMODULE   hModule
; 20   :                                            puintStringID ,						// _In_     UINT      uID
; 21   : 									       ( LPTSTR ) &lpTheString ,			// _Out_    LPTSTR    lpBuffer
; 22   : 										   RCDATA_INPLACE_POINTER ) 			// _In_     int       nBufferMax
; 23   : 											- TRAILING_NULL_ALLOWANCE_P6C ) )
; 24   : 		{	// Have pointer, will return.
; 25   : 			return lpTheString ;
; 26   : 		}	// if ( ( *plpuintLength = LoadString ( phSourceModule , puintStringID , ( LPTSTR ) &lpTheString , RCDATA_INPLACE_POINTER ) ) )
; 27   : 	}	// TRUE (Return the string length through the supplied pointer) block, if ( plpuintLength )
; 28   : 	else
; 29   : 	{
; 30   : 		if ( LoadString ( phSourceModule ,										// _in_     HMODULE   hModule
; 31   : 			              puintStringID ,										// _In_     UINT      uID
; 32   : 			              ( LPTSTR ) &lpTheString ,								// _Out_    LPTSTR    lpBuffer
; 33   : 			              RCDATA_INPLACE_POINTER ) )							// _In_     int       nBufferMax

	push	0
	lea	eax, DWORD PTR _lpTheString$[ebp]
	mov	DWORD PTR _lpTheString$[ebp], 0
	push	eax
	mov	esi, edx
	push	esi
	push	0
	call	DWORD PTR __imp__LoadStringW@16
	test	eax, eax
	je	SHORT $LN1@SOff_GetUn

; 34   : 		{	// Have pointer, will return.
; 35   : 			return lpTheString ;

	mov	eax, DWORD PTR _lpTheString$[ebp]
	pop	esi

; 50   : }	// SOff_GetUnicodeStringPointer

	mov	esp, ebp
	pop	ebp
	ret	4
$LN1@SOff_GetUn:

; 36   : 		}	// if ( LoadString ( phSourceModule , puintStringID , ( LPTSTR ) &lpTheString , RCDATA_INPLACE_POINTER ) )
; 37   : 	}	// FALSE (The caller said that it doesn't need to know how long the string is.) block, if ( plpuintLength )
; 38   : 
; 39   : 	//	------------------------------------------------------------------------
; 40   : 	//	Make a report about the error retrievable through FB_GetlpErrMsgSprintf,
; 41   : 	//	then return NULL (always NULL) to signal the caller to fetch the message
; 42   : 	//	or do whatever else it wants about the load error. If the Structured
; 43   : 	//	Exception Handling flag is enabled, this call won't actually return,
; 44   : 	//	because raising the exception unwinds the stack.
; 45   : 	//	------------------------------------------------------------------------
; 46   : 
; 47   : 	return ( LPTSTR ) SOff_ReportLoadStringError ( phSourceModule ,
; 48   : 		                                           puintStringID ,
; 49   : 		                                           RCDATA_INPLACE_POINTER ) ;

	push	ecx
	mov	edx, esi
	call	_SOff_ReportLoadStringError@12
	pop	esi

; 50   : }	// SOff_GetUnicodeStringPointer

	mov	esp, ebp
	pop	ebp
	ret	4
_SOff_GetUnicodeStringPointer@12 ENDP
_TEXT	ENDS
END
